1. How to define int size() for different types?


2. Split register pool by register type?


3. Where/when to add stuff to symbol table? In parser actions? Or in emitMips()?

5. How does Register/RegisterPool work?
global, stack of registers
emit returns register

x. emitMips() emits string?
yep

offset? assign to permanent memory?

what to store? lval? what does lval have? a type and

how to store strings? use string buffer? is string primitive with size 4?

what emits registers and what does not?
the write statement does not.
variableExprs do (need to load word from address and store to temp reg)
constExprs do (need to be loaded immediate to temp reg)

what opExprs do?
binOp for sure

WRITE statement mips code emission
-----------------------------------
Hard|
-----
1. store all string constants in .data
2. calculate string buffer space by
    * if stringConst or stringVar:
        get length of string in bytes
        def strlen()
    * elif chrConst or chrVar:
        add 1
    * elif intConst or intVar:
        def intlen()
        add intlen()
    * elif boolConst or boolVar:
        add 1
3. store string buffer in .data
4. join strings to string buffer
5. load string
6. syscall

-----
Medium?|
-----
1. store all string constants in .data
2. allocate 1000 bytes to string buffer in .data
3. join strings to string buffer
4. load string buffer
5. syscall
6. clear string buffer

-----
Easy|
-----
1. store all string constants in .data
2. print using mips calls

ARRAYS
---------
How should lval lookup vars stored in an array?

Lval stores array id:
    If no exts, return symbol (expr, offset)

Lval stores exts:
    If exts, return temp symbol with offset


SimpleType is like -> id : (array begin end type)




REGISTERS
---------

LVAL
----
$25 currOffsetReg
$21 add for currOffset

$25 45044 c
$23 1
$22 22476


crazy: 224760
record: 22476
a: 22472
g: 22464
array: 2496
record: 96
d: 84

BUG: VarAssign IN RECORD IS STILL ADDING TO SYMBOL TABLE

First assignment is working correctly


FUNCTIONS
---------
* Activation record
    ** saved local registers
    ** actual parameters
    ** return address
    ** old frame pointer
    ** local variables

* Prolog
    ** save local registers
        *** caller should save off all registers OR all registers it knows it currently has in use
    ** generate label for procedure
    ** push return address on stack
        *** caller: add return address to one of the caller saved registers
        *** callee:
    ** push frame pointer on stack
        *** before function call, run through all currently allocated registers
    ** update the frame pointer to point to new record
    ** allocate space for local variables for local variables
        *** last two have to be done by caller

* Epilog
    ** generate epilog label
    ** update frame pointer
    ** replace value of return address from stack
    ** deallocate parameters
    ** restore local registers
    ** jump to return address

* Return
    ** allocate space on stack for return value
    ** jump to return address

* Formal params
    ** dual definitions
        *** part of signature
        *** identifiers at local scope
    ** identifiers have positive offsets from frame pointer (caller puts them there)
        *** caller positive from fp, callee negative
        *** formal params positive from fp
        *** add params to signature, push new scope, add all params AGAIN with positive offsets

* Actual params
    ** Found at call site
    ** add to top of stack then move frame pointer


MIPS
--------------------
add:
    # move frame to current stack pointer
    ori $fp, $sp, 0
    # load params
    lw $t0, 4($fp)
    lw $t1, 8($fp)
    # add
    add $t0, $t0, $t1
    # sw for return value
    sw $t0, 0($fp)
    # return
    jr $ra

main:
    # assignment
    li $t0, 1
    sw $t0, 0($gp)
    li $t0, 2
    sw $t0, 4($gp)
    ...
    # load params
    lw $t0, 0($gp)
    lw $t1, 4($gp)
    # add current reg, ra, and fp to stack
    addi $sp, $sp, -16
    sw $t0, 0($sp)
    sw $t1, 4($sp)
    sw $ra, 8($sp)
    sw $fp, 12($sp)
    # local scope
    addi $sp, $sp, -12
    sw $t0, 4($sp)
    sw $t1, 8($sp)
    # add function
    jal add
    # load return value
    lw t2, 0($sp)
    # clear add function stack
    addi $sp, $sp, 12
    # restore regs, ra, fp
    lw $t0, 0($sp)
    lw $t1, 4($sp)
    lw $ra, 8($sp)
    lw $fp, 12($sp)
    addi $sp, $sp, 16

1. How to refer to stack variables in outer scope?
2. How to handle function signatures?
3. How to change procCall to expr?
4. How to pass by reference?

1. symboltable.enterScope()
    a. save reg pool state
    b. save regs, locations w/ dict
    c. move args to stack
    d. push scope
    e. load params to new scope symboltable

2. symboltable.exitscope()
    a. pop scope
    b. restore regpool state
    c. load spilled regs


1. procCall
    a. emit function mips here (all vars and params will be in proper place in symboltable for function to see)

* pass by ref
save address to stack
* how will the statements inside the function know how to access that variable by ref?
    * pass base address
    * have symbol for storing address
    if symbol is address:



[$fp1]

var
var
arg
arg

[$fp2]

var
var
$sp
